---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by bladeyuan.
--- DateTime: 2024/6/13 2:58
---
local SPAbility = require("Feature.StarP.Script.System.Ability.SPAbilityClasses")
local SPAbilityUtils = require("Feature.StarP.Script.System.Ability.SPAbilityUtils")
local SPLuaUtility = require("Feature.StarP.Script.System.SPLuaUtility")
local Ability_Task_JumpTo = UE4.Class(nil, "Ability_Task_JumpTo")

function Ability_Task_JumpTo:OnTaskStartBP(Context)
    local TargetArray = UE4.TArray(UE4.AActor)
    self:GetActorsForTaskBP(Context, TargetArray)

    for i = 1, TargetArray:Length() do
        local Target = TargetArray:Get(i)
        local Character = Target:Cast(UE4.ASPGameMonsterBase)
        if not Character then
            Character = Target:Cast(UE4.ASPGameCharacterBase)
        end

        if Character then
            local Transform = UE4.USPAbilityFunctionLibrary.GetAbilityTargetTypeLocationTransform(Context, self.Location)
            local Translation = Transform.Translation
            -- Add UltimateOffset
            if self.UseUltimateOffset == true then
                local ultimateOffset = self:GetUltimateOffset(Character)
                if ultimateOffset ~= nil then
                    Translation = Translation + ultimateOffset
                end
            end

            if self.JumpForward then
                local CharacterMeshComponent = Character:GetComponentByClass(UE4.USkeletalMeshComponent.StaticClass())
                local CharacterForward = UE4.FVector(0,0,0)
                if CharacterMeshComponent ~= nil then
                    --- Mesh取前向使用GetRightVector
                    CharacterForward = CharacterMeshComponent:GetRightVector()
                end
                local ForwardDistance = self:GetDuration() * self.ForwardSpeed
                Translation = Translation + CharacterForward * ForwardDistance
            end

            -- Limit its jump distance
            if self.MaxDistance and self.MaxDistance > 0 then
                Translation = self:LimitJumpToLocationDistance(Character:K2_GetActorLocation(), Translation, self.MaxDistance)
            end

            if self.IgnoreTargetCollision and Character.CapsuleComponent then
                Character.CapsuleComponent:SetCollisionResponseToChannel(UE4.USPGameLibrary.GetCollisionChannelBySPTraceType(UE4.ESPTraceType.Pawn), UE4.ECollisionResponse.ECR_Ignore)
                Character.CapsuleComponent:SetCollisionResponseToChannel(UE4.USPGameLibrary.GetCollisionChannelBySPTraceType(UE4.ESPTraceType.CallMonster), UE4.ECollisionResponse.ECR_Ignore)
                Character.CapsuleComponent:SetCollisionResponseToChannel(UE4.USPGameLibrary.GetCollisionChannelBySPTraceType(UE4.ESPTraceType.WildMonster), UE4.ECollisionResponse.ECR_Ignore)
            end

            local TargetActor = self:GetSingleActorFromTargetTypeBP(Context, UE4.EAbleAbilityTargetType.ATT_TargetActor)

            self:JumpTo(Context, Character, Translation, TargetActor)
        end
    end
end

function Ability_Task_JumpTo:OnTaskEndBP(Context, Result)
    local TargetArray = UE4.TArray(UE4.AActor)
    self:GetActorsForTaskBP(Context, TargetArray)

    for i = 1, TargetArray:Length() do
        local Target = TargetArray:Get(i)
        if self.IgnoreTargetCollision and _SP.IsValid(Target) and Target.CapsuleComponent then
            Target.CapsuleComponent:SetCollisionResponseToChannel(UE4.USPGameLibrary.GetCollisionChannelBySPTraceType(UE4.ESPTraceType.Pawn), UE4.ECollisionResponse.ECR_Block)
            Target.CapsuleComponent:SetCollisionResponseToChannel(UE4.USPGameLibrary.GetCollisionChannelBySPTraceType(UE4.ESPTraceType.CallMonster), UE4.ECollisionResponse.ECR_Block)
            Target.CapsuleComponent:SetCollisionResponseToChannel(UE4.USPGameLibrary.GetCollisionChannelBySPTraceType(UE4.ESPTraceType.WildMonster), UE4.ECollisionResponse.ECR_Block)
        end
    end


    if Result ~= UE4.EAbleAbilityTaskResult.Interrupted then
        --最终修正
        if self.bFinalFix then
            local TargetActor = Context:GetOwner()
            local TargetLocation = UE4.USPAbilityFunctionLibrary.GetAbilityTargetTypeLocationTransform(Context, self.Location).Translation
            TargetActor:K2_SetActorLocation(TargetLocation)
        end
        return
    end

    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad or not ScratchPad.Handle then
        return
    end

    ScratchPad.Handle:Abort()
    ScratchPad.Handle = nil
end

function Ability_Task_JumpTo:JumpTo(Context, Target, TargetLocation, TargetActor)
    local Handle = nil
    if self.UseGravityMultiplier then
        ---@TODO: fake code
        -- Handle = Target:JumpToTargetLocationWithGravityMultiplier(TargetLocation, self:GetDuration(), self.MaxHeight, self.GravityMultiplier)
        -- NotImplemented
        return
    elseif self.KeepForwardToTarget then
        if _SP.IsValid(TargetActor) then
            local Config = UE4.USPCharacterMovementLibrary.GetMovementConfigV3(true, self.IgnorePitch, self.IgnoreYaw, self.IgnoreRoll, self.IgnoreWalkableAngle)
            Handle = Target:JumpToTargetLocationForwardTarget(TargetActor, TargetLocation, self:GetDuration(), self.MaxHeight, Config)
        end
    else
        local Config = UE4.USPCharacterMovementLibrary.GetMovementConfigV3(true, self.IgnorePitch, self.IgnoreYaw, self.IgnoreRoll, self.IgnoreWalkableAngle)
        Handle = Target:JumpToTargetLocationWithConfig(TargetLocation, self:GetDuration(), self.MaxHeight, Config)
    end

    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        return
    end

    ScratchPad.Handle = Handle

    if self.StopJumpingWhenCollide and false then
        ---@TODO: Jump handle should have a abort callback to end this task
        -- Handle.OnCollideEvent:Add(self, )
    end
end

function Ability_Task_JumpTo:IsSingleFrameBP()
    return false
end

function Ability_Task_JumpTo:ResetScratchPadBP(ScratchPad)
    if ScratchPad then
        ScratchPad.Handle = nil
    end
end

function Ability_Task_JumpTo:GetTaskScratchPadClassBP(Context)
    return SPAbilityUtils.LoadScratchPadClass(SPAbility.ScratchPadClass.JumpTo)
end

function Ability_Task_JumpTo:GetUltimateOffset(Character)
    local pet = Character:GetUnleashedPet()
    if pet == nil then
        return nil
    end

    local petTypeConfig = pet:GetMonsterTypeConfig()
    if petTypeConfig == nil then
        return nil
    end

    local offset = petTypeConfig.OffsetLocForTalentUltimate
    if offset ~= nil then
        return UE4.FVector(0, 0, offset[3])
    end
    return UE4.FVector(0, 0, 50)
end


--- 跳跃最大距离限制
---     水平距离限制
---     当跳跃目标超过最大距离的时候，会以目标-施法者两点连线上的最大距离点作为目标点
---@return float FixedJumpToLocation
function Ability_Task_JumpTo:LimitJumpToLocationDistance(CharacterLocation ,OriginJumpToLoation, MaxDistance)
    local OriginDistance = UE4.UKismetMathLibrary.Vector_Distance(CharacterLocation, OriginJumpToLoation)
    if MaxDistance > OriginDistance then
        return OriginJumpToLoation
    end

    local Direction = UE4.UKismetMathLibrary.GetDirectionUnitVector(CharacterLocation, OriginJumpToLoation)
    return CharacterLocation + UE4.UKismetMathLibrary.Multiply_VectorFloat(Direction, MaxDistance)
end

return Ability_Task_JumpTo