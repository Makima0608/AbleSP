---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by recano_xuanquan.
--- DateTime: 24.12.20
---
local SPAbility = require("Feature.StarP.Script.System.Ability.SPAbilityClasses")
local SPAbilityUtils = require("Feature.StarP.Script.System.Ability.SPAbilityUtils")
local Ability_Task_Leihou_CheckSkillValid = UE4.Class(nil, "Ability_Task_Leihou_CheckSkillValid")

function Ability_Task_Leihou_CheckSkillValid:OnTaskStartBP(Context)
    self.SelfHalfHeight = Context:GetOwner().CapsuleComponent:GetScaledCapsuleHalfHeight()

    -- 获取攻击后排
    local Target = self:GetAttackActor(Context) or UE4.UGameplayStatics.GetPlayerCharacter(_SPFeature.Utils.WorldUtils:GetCurrentWorld(), 0)   -- 获得对方后排
    if Target == nil then
        Context:GetSelfAbilityComponent():InterruptActiveAbility("interrupt from Task_Leihou_CheckSkillValid", _SP.IsDSorStandalone)	--打断当前技能
        return
    end
    self.Target = Target
    self.TargetHalfHeight = Target.CapsuleComponent and Target.CapsuleComponent:GetScaledCapsuleHalfHeight() or 100
    --获取合法落点
    local ValidLocations = self:GetValidSummonLocation(Target, Context)
    if ValidLocations == nil then
        Context:GetSelfAbilityComponent():InterruptActiveAbility("interrupt from Task_Leihou_CheckSkillValid", _SP.IsDSorStandalone)	--打断当前技能
        return
    end
    --将金箍棒落点和角色落点传入context
    Context:SetTargetLocations(ValidLocations)

end

function Ability_Task_Leihou_CheckSkillValid:OnTaskEndBP(Context)
    local ScratchPad = self:GetScratchPad(Context)
    if ScratchPad then
        print("Ability_Task_Leihou_CheckSkillValid:OnTaskEndBP !!!", ScratchPad.step)
    end
end

function Ability_Task_Leihou_CheckSkillValid:IsSingleFrameBP()
    return true
end

function Ability_Task_Leihou_CheckSkillValid:GetTaskScratchPadClassBP(Context)
    return SPAbilityUtils.LoadScratchPadClass(SPAbility.ScratchPadClass.TemplatePad)
end

-------------------------------------------------------------
--[[ 落点合法性实现方案
1.概述：在金箍棒生成坐标附近进行判定，选取可以释放的坐标，如果没有就不能释放该技能

2.原理：雷猴当前位置A，雷猴跳跃点B，目标点C（金箍棒落点），三点一线。显然B和C距离保持相对不变，检测位置合法就是看B和C;

检测范围为线段AC上，以C为端点，长度为R的一小段，距离R策划配表。按步进的规则进行选点，步进距离step配表，选到合法的点（没有障碍和坑洞）作为最终落点；

3.举例：检测范围为1米，步进距离为0.1米，总共有10个位置可以挑选，从C点出发沿AC方向往回选点，每次回退0.1米，回退10次都不行，就放弃释放该技能
]]--------------------------------------------------------------

---现有的射线检测方法不能完全支持检测需求，因此自己写一个新的，也便于扩展
---@param position 待检测落点
---@param radius 通常是胶囊体半径
---@param halfHeight 射线一半的高度因为要两头发射
---@param bDrawDebug 是否DebugDraw
function Ability_Task_Leihou_CheckSkillValid:SphereTraceObstacle(position, radius, halfHeight, bDrawDebug, TraceColor, TraceHitColor)
    local DetectObjectTypes = UE4.TArray(UE4.EObjectTypeQuery)
    DetectObjectTypes:Add(UE4.UMoeBlueprintLibrary.ConvertToObjectType(UE4.USPGameLibrary.GetCollisionChannelBySPTraceType(UE4.ESPTraceType.GameBuilding)))
    DetectObjectTypes:Add(UE4.UMoeBlueprintLibrary.ConvertToObjectType(UE4.USPGameLibrary.GetCollisionChannelBySPTraceType(UE4.ESPTraceType.BlockBuilding)))
    DetectObjectTypes:Add(UE4.UMoeBlueprintLibrary.ConvertToObjectType(UE4.USPGameLibrary.GetCollisionChannelBySPTraceType(UE4.ESPTraceType.WorldStatic)))

    local HitResult = UE4.FHitResult()
    local DebugType = bDrawDebug and self.DebugTraceType or UE4.EDrawDebugTrace.None
    --使用球形检测，因为要考虑胶囊体尺寸
    local bHit = UE4.UKismetSystemLibrary.SphereTraceSingle(
        self.Target,
        position + UE4.FVector(0,0,halfHeight),
        position - UE4.FVector(0,0,halfHeight),
        radius or 100,
        UE4.ETraceTypeQuery.Visibility,
        false,
        nil,
        DebugType,
        HitResult,
        true,
        TraceColor,
        TraceHitColor,
        self.DrawTime
    )

    if bHit then
        local point = HitResult.ImpactPoint
        return bHit, point.Z
    else
        return bHit, nil
    end

end

---检查金箍棒落点是否合法，参数的坐标只有XY平面是有效的，实际高度会受碰撞和重力影响
---@param smLocation 金箍棒理论落点
---@param jumpLocation 跳跃理论落点
function Ability_Task_Leihou_CheckSkillValid:CheckSummonLocationValid(smLocation, jumpLocation)
    --金箍棒落点

    local smHit, smZ = self:SphereTraceObstacle(
        smLocation, self.StickRadius, self.ToleranceHeight_T2S + self.TargetHalfHeight, self.bDrawStick, self.StickColor, self.TraceHitColor)
    --跳跃落点分两步检测，先射线检测理论落点位置，再检测猴子胶囊体能否到达
    local jumpHit,jumpZ = self:SphereTraceObstacle(
        jumpLocation,
        self.StickRadius,    -- 检测跳跃落点复用棍子半径
        self.ToleranceHeight_J2S + self.SelfHalfHeight, self.bDrawJump, self.JumpColor, self.TraceHitColor)
    if smZ and jumpZ then
        if math.abs(smZ - jumpZ) < self.ToleranceHeight_J2S then
            -- 跳跃点二次检测，判断猴子是否足够有落地的空间
            local fixedJumpLocation = UE4.FVector(jumpLocation.X,jumpLocation.Y,jumpZ + self.SelfHalfHeight)
            local jumpHit2,jumpZ2 = self:SphereTraceObstacle(
                fixedJumpLocation, self.JumpRadius,
                math.max(0,self.SelfHalfHeight - self.JumpRadius - 10),     -- 检测高度要比实际胶囊体略小一点，避免边界碰撞
                self.bDrawJump, self.JumpColor, self.TraceHitColor)
            --无碰撞，表示有落地空间
            if not jumpHit2 then
                --修正落点高度
                smLocation.Z = smZ --+ self.SelfHalfHeight
                jumpLocation.Z = jumpZ + self.SelfHalfHeight + 2.15
                return true
            end
        end
    end

    return false
end

-- 步进获取合法点
function Ability_Task_Leihou_CheckSkillValid:GetValidSummonLocation(targetActor, Context)
    --fvector乘法
    local function multiVector(k,vector)
        return UE4.FVector(k*vector.X, k*vector.Y, k*vector.Z)
    end

    local checkNum = math.floor(self.CheckRange / self.CheckStep)    --计算出判定次数
    local smLocation = targetActor:K2_GetActorLocation()
    -- 计算方向
    local direction = smLocation - Context:GetOwner():K2_GetActorLocation()
    direction.Z = 0
    direction:Normalize()   --方向归一化

    smLocation = smLocation - multiVector(50, direction)       -- 落点距离玩家坐标稍微错开一点，防止击退获取不到正确方向
    local jumpLocation = smLocation - multiVector(self.JumpOffset, direction)

    local locations = UE4.TArray(UE4.FVector)   --保存雷猴跳跃点B，目标点C（金箍棒落点）

    for i = 1,checkNum,1 do
        if self:CheckSummonLocationValid(smLocation, jumpLocation) then
            locations:Add(smLocation)
            locations:Add(jumpLocation)
            return locations
        else
            smLocation = smLocation - multiVector(self.CheckStep, direction)
            jumpLocation = smLocation - multiVector(self.JumpOffset, direction)
        end
    end

    return nil      -- 没有合法位置则返回空
end

---获取距离的平方，用于比大小，避免开方提高性能
---sourceActor targetActor AActor
function Ability_Task_Leihou_CheckSkillValid:GetSqrtDistance(sourceActor, targetActor)
    if sourceActor == nil or targetActor == nil then
        return -1
    end

    local s_location = sourceActor:K2_GetActorLocation()
    local t_location = targetActor:K2_GetActorLocation()
    local distance = t_location - s_location
    return distance:SizeSquared()
end

function Ability_Task_Leihou_CheckSkillValid:GetAttackActor(Context)
    -- 最远的对象视为该技能攻击对象
    local sourceActor = Context:GetOwner()
    local TargetArray = Context:GetTargetActors()
    --local TargetArray = UE4.TArray(UE4.AActor)
    --self:GetActorsForTaskBP(Context, TargetArray)

    local farthestTarget = TargetArray:Length() > 0 and TargetArray:Get(1) or nil
    local farthestDistance = self:GetSqrtDistance(sourceActor, farthestTarget)
    for i = 2, TargetArray:Length() do
        local Target = TargetArray:Get(i)
        local distance = self:GetSqrtDistance(sourceActor, Target)
        if distance > farthestDistance then
            farthestTarget = Target
            farthestDistance = distance
        end
    end

    --只保留一个target
    Context:ClearTargetActors()
    local newActorArray = UE4.TArray(UE4.AActor)
    newActorArray:Add(farthestTarget)
    Context:AddTargetActors(newActorArray)
    return farthestTarget
end
return Ability_Task_Leihou_CheckSkillValid