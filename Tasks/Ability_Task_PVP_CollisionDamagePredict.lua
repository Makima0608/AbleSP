---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by coochen.
--- DateTime: 2025/02/28 16:00
---

local SPAbilityUtils = require("Feature.StarP.Script.System.Ability.SPAbilityUtils")
local SPAbility = require("Feature.StarP.Script.System.Ability.SPAbilityClasses")

local IsValid = _SP.IsValid
local math_max = math.max
local ipairs = ipairs
local table_insert = table.insert
local CommonUtils = _SPFeature.Utils.CommonUtils

local function Log(...)
    _SP.Log("SPAbility", "[Ability_Task_PVP_CollisionDamagePredict]", ...)
end

local function Warning(...)
    _SP.LogWarning("SPAbility", "[Ability_Task_PVP_CollisionDamagePredict]", ...)
end

local function Error(...)
    _SP.LogError("SPAbility", "[Ability_Task_PVP_CollisionDamagePredict]", ...)
end

---@class Ability_Task_PVP_CollisionDamagePredict_New : USPAbilityTask
---@field ShapeRange FAbilityShapeRange
local Ability_Task_PVP_CollisionDamagePredict = UE4.Class(nil, "Ability_Task_PVP_CollisionDamagePredict")

function Ability_Task_PVP_CollisionDamagePredict:OnTaskStartBP(Context)
    ---@type Ability_Task_PVP_CollisionDamagePredictPad
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        Warning("[OnTaskStartBP]", "ScratchPad is nil")
        return
    end

    -- 初始化ScratchPad数据
    ScratchPad.DamageMap = {}
    ScratchPad.Time = self:GetTaskStartTimeBP()
    ScratchPad.Owner = self:GetSingleActorFromTargetTypeBP(Context, UE4.EAbleAbilityTargetType.ATT_Self)
    ScratchPad.OwnerActorType = ScratchPad.Owner.GetSPActorType and ScratchPad.Owner:GetSPActorType()
    ScratchPad.Instigator = Context:GetInstigator() or ScratchPad.Owner
    ScratchPad.AbilityId = Context:GetAbilityId()
    ScratchPad.bInterrupt = false
    ScratchPad.bDamage = true
    ScratchPad.RangeUpdateIntervalControlTime = 0

    Log("[OnTaskStartBP]", "AbilityId:", ScratchPad.AbilityId)

    -- 初始化碰撞范围数据
    self:InitShapeRange(ScratchPad)

    -- 模拟碰撞并进行预测伤害
    self:SimulationCollisionAndPredictDamage(ScratchPad, Context, true)
end

function Ability_Task_PVP_CollisionDamagePredict:OnTaskTickBP(Context, DeltaTime)
    ---@type Ability_Task_PVP_CollisionDamagePredictPad
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
       Warning("[OnTaskTickBP]", "ScratchPad is nil")
       return
    end

    --计算时间
    ScratchPad.Time = ScratchPad.Time + DeltaTime
    ScratchPad.RangeUpdateIntervalControlTime = ScratchPad.RangeUpdateIntervalControlTime + DeltaTime

    -- 模拟碰撞并进行预测伤害
    self:SimulationCollisionAndPredictDamage(ScratchPad, Context)
end

function Ability_Task_PVP_CollisionDamagePredict:OnTaskEndBP(Context, Result)
    ---@type Ability_Task_PVP_CollisionDamagePredictPad
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        Warning("[OnTaskEndBP]", "ScratchPad is nil")
        return
    end

    ScratchPad.Time = self:GetTaskEndTimeBP()

    if not self:IsSingleFrameBP() and
            Result == UE4.EAbleAbilityTaskResult.Successful then
        -- 检测碰撞并预测进行伤害
        self:SimulationCollisionAndPredictDamage(ScratchPad, Context, false, true)
    else
        _SP.DS.SPPVPHarmPredictionManager:OnClearPVPCollisionDmagePredict(self:GetName())
    end

    -- 清理ScratchPad数据
    self:ClearScratchPad(ScratchPad)
end

---@param ScratchPad UAbleAbilityTaskScratchPad
function Ability_Task_PVP_CollisionDamagePredict:ResetScratchPadBP(ScratchPad)
    -- 清理ScratchPad数据
    self:ClearScratchPad(ScratchPad)
end

---@param ScratchPad Ability_Task_CollisionDamagePad
function Ability_Task_PVP_CollisionDamagePredict:ClearScratchPad(ScratchPad)
    ScratchPad.DamageMap = nil
    ScratchPad.BuffMap = nil
    ScratchPad.Time = nil
    ScratchPad.Owner = nil
    ScratchPad.OwnerActorType = nil
    ScratchPad.Instigator = nil
    ScratchPad.AbilityId = nil
    ScratchPad.AbilityUniqueID = nil
    ScratchPad.bInterrupt = nil
    ScratchPad.bDamage = nil
    ScratchPad.bCanThisCollisionTriggerDodge = nil
    ScratchPad.RangeUpdateIntervalControlTime = nil
    ScratchPad.HighPingPawns = nil
    ScratchPad.DamageConfig = nil
    ScratchPad.HitConfig = nil
    ScratchPad.Orientation = nil
    ScratchPad.HitResults = nil
    ScratchPad.DamageResults = nil
end

function Ability_Task_PVP_CollisionDamagePredict:GetTaskScratchPadClassBP(Context)
    return SPAbilityUtils.LoadScratchPadClass(SPAbility.ScratchPadClass.PVPCollisionDamagePredict)
end

---InitShapeRange
---初始化碰撞范围数据
---@param ScratchPad Ability_Task_PVP_CollisionDamagePredictPad
function Ability_Task_PVP_CollisionDamagePredict:InitShapeRange(ScratchPad)
    if not self.bUpdateVelocity and not self.AdaptOwnerScale then
        return
    end
    ---@type FAbilityShapeRange
    local ShapeRange = {
        HalfExtents = self.ShapeRange.HalfExtents,
        Radius = self.ShapeRange.Radius,
        HalfHeight = self.ShapeRange.HalfHeight,
        ConeRadius = self.ShapeRange.ConeRadius,
        ConeLength = self.ShapeRange.ConeLength,
        CylinderInnerRadius = self.ShapeRange.CylinderInnerRadius,
        CylinderOuterRadius = self.ShapeRange.CylinderOuterRadius,
        CylinderHeight = self.ShapeRange.CylinderHeight,
        CylinderAngle = self.ShapeRange.CylinderAngle,
        CylinderInitialOuterRadius = self.ShapeRange.CylinderOuterRadius,
        CylinderChangeOuterRadius = self.CylinderMaxOuterRadius - self.ShapeRange.CylinderOuterRadius
    }

    -- 如果配置的最大外环Radius为负数，则以要向内缩放到0处理
    if self.CylinderMaxOuterRadius < 0 then
        ShapeRange.CylinderChangeOuterRadius = -self.ShapeRange.CylinderOuterRadius
    end

    -- 是否跟随释放者的缩放跳转伤害范围
    if self.AdaptOwnerScale then
        local Owner = ScratchPad.Owner
        if IsValid(Owner) then
            local OwnerScale = Owner:GetActorScale3D()
            if self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Box then
                -- 如果是Box，根据Scale信息分别缩放XYZ即可
                ShapeRange.HalfExtents = ShapeRange.HalfExtents * OwnerScale
            elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Sphere then
                -- 如果是Sphere，更具Scale信息中最大值缩放Radius
                local MaxScaleValue = math_max(OwnerScale.X, OwnerScale.Y, OwnerScale.Z)
                ShapeRange.Radius = ShapeRange.Radius * MaxScaleValue
            elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Capsule then
                -- 如果是Capsule，那么Scale的XY影响Radius，Z值影响HalfHeight
                local MaxHorizontalScaleValue = math_max(OwnerScale.X, OwnerScale.Y)
                ShapeRange.Radius = ShapeRange.Radius * MaxHorizontalScaleValue
                ShapeRange.HalfHeight = ShapeRange.HalfHeight * OwnerScale.Z
            elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Cone then
                -- 如果是Cone，默认预览中，XZ控制Raidus，Y控制Length
                local MaxVerticalScaleValue = math_max(OwnerScale.X, OwnerScale.Z)
                ShapeRange.ConeRadius = ShapeRange.ConeRadius * MaxVerticalScaleValue
                ShapeRange.ConeLength = ShapeRange.ConeLength * OwnerScale.Y
            elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Cylinder then
                -- 如果是Cylinder，XY影响Radius，Z影响Height，Angle不受影响
                local MaxHorizontalScaleValue = math_max(OwnerScale.X, OwnerScale.Y)
                ShapeRange.CylinderInnerRadius = ShapeRange.CylinderInnerRadius * MaxHorizontalScaleValue
                ShapeRange.CylinderOuterRadius = ShapeRange.CylinderOuterRadius * MaxHorizontalScaleValue
                ShapeRange.CylinderHeight = ShapeRange.CylinderHeight * OwnerScale.Z
                ShapeRange.CylinderInitialOuterRadius = self.CylinderMaxOuterRadius
                local ScaledCylinderMaxOuterRadius = self.CylinderMaxOuterRadius * MaxHorizontalScaleValue
                ShapeRange.CylinderChangeOuterRadius = ScaledCylinderMaxOuterRadius - self.ShapeRange.CylinderOuterRadius
            end
        end
    end

    ScratchPad.ShapeRangeBase = ShapeRange
    ScratchPad.ShapeRange = CommonUtils:DeepCopy(ShapeRange)
end

---SimulationCollisionAndPredictDamage
---模拟碰撞并预测造成伤害
---@param ScratchPad Ability_Task_PVP_CollisionDamagePredictPad
---@param Context UAbleAbilityContext
function Ability_Task_PVP_CollisionDamagePredict:SimulationCollisionAndPredictDamage(ScratchPad, Context, bStart, bEnd)
    -- 更新碰撞范围数据
    self:UpdateShapeRange(ScratchPad)
    -- 模拟碰撞检测
    self:SimulationCollision(ScratchPad, Context, bStart)
    -- 预测造成伤害
    self:BoardcastSimulationDmg(ScratchPad, Context, bEnd)
end

---UpdateShapeRange
---更新碰撞范围数据
---@param ScratchPad Ability_Task_PVP_CollisionDamagePredictPad
function Ability_Task_PVP_CollisionDamagePredict:UpdateShapeRange(ScratchPad)
    if not self.bUpdateVelocity then
        return
    end
    if self.UseCustomRangeUpdateInterval and self.CustomRangeUpdateInterval > 0 then
        -- 使用自定义更新间隔
        if ScratchPad.RangeUpdateIntervalControlTime < self.CustomRangeUpdateInterval then
            return
        else
            ScratchPad.RangeUpdateIntervalControlTime = 0
        end
    end
    local ShapeRangeBase = ScratchPad.ShapeRangeBase
    local ShapeRange = ScratchPad.ShapeRange

    local CurrTime = ScratchPad.Time - self:GetTaskStartTimeBP()

    if CurrTime == 0 then
        return
    end

    if self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Box then
        if self.ExtendsXUpdateTime > 0 then
            local Percent = CurrTime / self.ExtendsXUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeExtendX = Percent * self.ExtendsXUpdateVelocity
            ShapeRange.HalfExtents.X =  ShapeRangeBase.HalfExtents.X + ChangeExtendX
        else
            -- ExtendsXUpdateTime配置为负数时匀速增加
            ShapeRange.HalfExtents.X =  ShapeRangeBase.HalfExtents.X + self.ExtendsXUpdateVelocity
        end
        if self.ExtendsYUpdateTime > 0 then
            local Percent = CurrTime / self.ExtendsYUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeExtendY = Percent * self.ExtendsYUpdateVelocity
            ShapeRange.HalfExtents.Y =  ShapeRangeBase.HalfExtents.Y + ChangeExtendY
        else
            -- ExtendsYUpdateVelocity配置为负数时匀速增加
            ShapeRange.HalfExtents.Y =  ShapeRangeBase.HalfExtents.Y + self.ExtendsYUpdateVelocity
        end
        if self.ExtendsZUpdateTime > 0 then
            local Percent = CurrTime / self.ExtendsZUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeExtendZ = Percent * self.ExtendsZUpdateVelocity
            ShapeRange.HalfExtents.Z =  ShapeRangeBase.HalfExtents.Z + ChangeExtendZ
        else
            -- ExtendsZUpdateVelocity配置为负数时匀速增加
            ShapeRange.HalfExtents.Z =  ShapeRangeBase.HalfExtents.Z + self.ExtendsZUpdateVelocity
        end
    elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Sphere then
        if self.RadiusUpdateTime > 0 then
            local Percent = CurrTime / self.RadiusUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeRadius = CurrTime / self.RadiusUpdateTime * self.RadiusUpdateVelocity
            ShapeRange.Radius =  ShapeRangeBase.Radius + ChangeRadius
        else
            -- RadiusUpdateVelocity配置为负数时匀速增加
            ShapeRange.Radius =  ShapeRangeBase.Radius + self.RadiusUpdateVelocity
        end
    elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Capsule then
        if self.HeightUpdateTime > 0 then
            local Percent = CurrTime / self.HeightUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeRadiusHeight = Percent * self.HeightUpdateVelocity
            ShapeRange.HalfHeight =  ShapeRangeBase.HalfHeight + ChangeRadiusHeight
        else
            -- HeightUpdateVelocity配置为负数时匀速增加
            ShapeRange.HalfHeight =  ShapeRangeBase.HalfHeight + self.HeightUpdateVelocity
        end
        if self.RadiusUpdateTime > 0 then
            local Percent = CurrTime / self.RadiusUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeRadius = Percent * self.RadiusUpdateVelocity
            ShapeRange.Radius =  ShapeRangeBase.Radius + ChangeRadius
        else
            -- RadiusUpdateVelocity配置为负数时匀速增加
            ShapeRange.Radius =  ShapeRangeBase.Radius + self.RadiusUpdateVelocity
        end
    elseif self.CollisionShape == SPAbilityUtils.EAbilityCollisionShape.Cylinder then
        if self.CylinderRadiusUpdateTime > 0 then
            local Percent = CurrTime / self.CylinderRadiusUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeCylinderRadius = Percent * ShapeRange.CylinderChangeOuterRadius
            -- 圆柱的Update需要考虑上一次的外环，不然会导致“跳环”情况
            ShapeRange.CylinderInnerRadius = ShapeRange.CylinderOuterRadius
            ShapeRange.CylinderOuterRadius = ShapeRange.CylinderInitialOuterRadius + ChangeCylinderRadius
        else
            -- CylinderRadiusUpdateVelovity配置为负数时匀速增加
            ShapeRange.CylinderInnerRadius = ShapeRange.CylinderInnerRadius + self.CylinderRadiusUpdateVelovity
            ShapeRange.CylinderOuterRadius = ShapeRange.CylinderOuterRadius + self.CylinderRadiusUpdateVelovity
        end
        if self.CylinderHeightUpdateTime > 0 then
            local Percent = CurrTime / self.CylinderHeightUpdateTime
            if Percent > 1 then Percent = 1 end
            local ChangeCylinderHeight = Percent * self.CylinderHeightUpdateVelocity
            ShapeRange.CylinderHeight = ShapeRange.CylinderHeight + ChangeCylinderHeight
        else
            -- CylinderHeightUpdateVelocity配置为负数时匀速增加
            ShapeRange.CylinderHeight = ShapeRange.CylinderHeight + self.CylinderHeightUpdateVelocity
        end
    end
end

---SimulationCollision
---模拟碰撞检测
---@param ScratchPad Ability_Task_PVP_CollisionDamagePredictPad
---@param Context UAbleAbilityContext
---@param bStart bool
function Ability_Task_PVP_CollisionDamagePredict:SimulationCollision(ScratchPad, Context, bStart)
    if not Context then
        return
    end
    local Owner = ScratchPad.Owner
    if not IsValid(Owner) then
        Warning("[SimulationCollision]", "Owner is nil")
        return
    end

    local TraceStart = nil
    local Orientation = nil

    if not self.bTickCollisionChange and not bStart then
        -- read location and rotation form the ScratchPad
        TraceStart = ScratchPad.TraceStart or Owner:K2_GetActorLocation()
        Orientation = ScratchPad.TraceRotation or Owner:K2_GetActorRotation()
    else
        local Transform = UE4.USPAbilityFunctionLibrary.GetAbilityTargetTypeLocationTransform(Context, self.QueryLocation)
        TraceStart = Transform.Translation
        Orientation = Transform.Rotation:ToRotator()
    end
    local ObjectTypes = _SP.SPAbilityUtils.GetObjectTypesPresent(Context, self.CollisionChannelPresent, self.CollisionObjectChannels)

    local HitResults = UE4.TArray(UE4.FHitResult)
    -- 这里使用ScratchPad.ShapeRange来确保Range的更新
    local ShapeRange = ScratchPad.ShapeRange or self.ShapeRange
    UE4.USPAbilityFunctionLibrary.DoCollisionDetect(Context, Owner, HitResults, self.CollisionShape, ObjectTypes, TraceStart, Orientation, false, ShapeRange.HalfExtents, ShapeRange.Radius, ShapeRange.ConeRadius,
    ShapeRange.ConeLength, ShapeRange.HalfHeight, ShapeRange.CylinderAngle, ShapeRange.CylinderInnerRadius, ShapeRange.CylinderOuterRadius, ShapeRange.CylinderHeight, _SP.IsDSorStandalone and _SP.DS._bShowDebugCollision, self.UseWorldStaticInTypes, self.bIgnoreSelf, self.bUseSweepInDetect)

    ScratchPad.Orientation = Orientation
    ScratchPad.HitResults = HitResults

    Log("[SimulationCollision]", "[DamageDebug]", "AbilityId:", ScratchPad.AbilityId, "HitResultsLength:", HitResults:Length())

    -- 配置过滤
    local Filters = self.Filter.m_Filters
    for i = 1, Filters:Length() do
        ---@type UAbleCollisionFilter
        local Filter = Filters:Get(i)
        Filter:FilterBP(Context, HitResults)
    end

    ScratchPad.CollisionResults = ScratchPad.HitResults:ToTable()
end

---BoardcastSimulationDmg
---预测伤害
---@param ScratchPad Ability_Task_PVP_CollisionDamagePredictPad
---@param Context UAbleAbilityContext
function Ability_Task_PVP_CollisionDamagePredict:BoardcastSimulationDmg(ScratchPad, Context, bEnd)
    ScratchPad.DamageResults = ScratchPad.CollisionResults

    _SP.DS.SPPVPHarmPredictionManager:OnCachePVPCollisionDamagePredict(self:GetName(), ScratchPad.AbilityId, ScratchPad.Instigator, ScratchPad.DamageResults, self.DamageId, self.DamageCoef, bEnd)
    Log("[BoardcastSimulationDmg]", "[DamageDebug]", "AbilityId:", ScratchPad.AbilityId, "DamageId:", ScratchPad.DamageId, "AbilityUniqueID:", Context:GetAbilityUniqueID())
end

return Ability_Task_PVP_CollisionDamagePredict