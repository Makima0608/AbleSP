---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by bladeyuan.
--- DateTime: 2024/6/21 19:48
---
local SPAbility = require("Feature.StarP.Script.System.Ability.SPAbilityClasses")
local SPAbilityUtils = require("Feature.StarP.Script.System.Ability.SPAbilityUtils")
local Ability_Task_MoveTo = UE4.Class(nil, "Ability_Task_MoveTo")
local EMoveType = {
    MoveToLocation = 0,
    MoveToDungeonSTP = 1
}

function Ability_Task_MoveTo:OnTaskStartBP(Context)
    local TargetArray = UE4.TArray(UE4.AActor)
    self:GetActorsForTaskBP(Context, TargetArray)

    if Context.GetRandomSeed then
        self:SetRandomStreamSeed(Context:GetRandomSeed())
    end

    for i = 1, TargetArray:Length() do
        local Target = TargetArray:Get(i)
        local Character = Target:Cast(UE4.ASPGameMonsterBase)
        self.bMonster = true
        if not Character then
            Character = Target:Cast(UE4.ASPGameCharacterBase)
            self.bMonster = false
        end

        local FinalLocataion = self.TargetLocation
        if self.MoveType == EMoveType.MoveToLocation then
            if Character then
                self:MoveTo(Context, Character, FinalLocataion)
            end
        elseif self.MoveType == EMoveType.MoveToDungeonSTP then
            self:MoveToDungeonSTP(Context, Character)
        end
    end
end

function Ability_Task_MoveTo:OnTaskTickBP(Context, DeltaTime)
    self:CheckIsMoveEnd(Context)
end

function Ability_Task_MoveTo:OnTaskEndBP(Context, Result)
    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad or not ScratchPad.Handle then
        return
    end

    if self.bForceSetOnEnd and ScratchPad.TargetYawAngle then
        local owner = Context:GetOwner()
        if owner and owner.SPSetActorRotation then
            local rotation = owner:K2_GetActorRotation()
            rotation.Yaw = ScratchPad.TargetYawAngle
            owner:SPSetActorRotation(rotation)
        end
    end
    if Result ~= UE4.EAbleAbilityTaskResult.Interrupted then
        return
    end

    ScratchPad.Handle:Abort()
    ScratchPad.Handle = nil
end

---@param Character AActor
---@return TargetLocation, TargetRotation
function Ability_Task_MoveTo:GetConfigDungeonSTP(Character)
    --获取Monster所在的关卡偏移量
    local Locationoffset = UE4.FVector(0, 0, 0)
    if self.bMonster then
        Locationoffset = Character:GetMonsterDungeonLoc()
    end

    local STPIDList = {}
    local bUsePrimaryKey = false
    if self.STPUIDList:Length() > 0 then
        bUsePrimaryKey = true
        for index = 1, self.STPUIDList:Length() do
            table.insert(STPIDList, self.STPUIDList:Get(index))
        end
    else
        for index = 1, self.STPIDList:Length() do
            table.insert(STPIDList, self.STPIDList:Get(index))
        end
    end

    --获取表中配置的STP信息
    local findSTPInfo = SPAbilityUtils.GetSTPConfigList(STPIDList, bUsePrimaryKey)

    -- 如果并未匹配到STP配置则不进行移动
    if #findSTPInfo == 0 then
        _SP.Log("Ability_Task_MoveTo", "MoveToDungeonSTP", "Unable to find matching STP points, Please check the ability configuration.")
        return nil, nil
    end

    local TargetLocation = nil
    local TargetRotation = nil
    --计算离目标最近的STP点
    local ownerLocation = Character:K2_GetActorLocation()
    local nearestDistance = nil
    for _, virtualPoint in ipairs(findSTPInfo) do
        local locParam = string.split(virtualPoint.pos, ',')
        local stpLocation = UE4.FVector(locParam[1], locParam[2], locParam[3]) + Locationoffset
        local distance = UE4.UKismetMathLibrary.Vector_Distance(ownerLocation, stpLocation)
        if nearestDistance == nil or distance < nearestDistance then
            nearestDistance = distance
            TargetLocation = stpLocation
            local rotParam = string.split(virtualPoint.rot, ',')
            TargetRotation = UE4.FVector(rotParam[1], rotParam[2], rotParam[3])
        end
    end

    return TargetLocation, TargetRotation
end

function Ability_Task_MoveTo:GetRandomPointInCircle(CenterPoint, radius)
    -- 随机角度和半径
    local angle = self:GetRandomFloat() * 2 * math.pi
    local r = radius * math.sqrt(self:GetRandomFloat())
    -- 计算随机点的坐标
    local x = CenterPoint.X + r * math.cos(angle)
    local y = CenterPoint.Y + r * math.sin(angle)
    return UE4.FVector(x, y, CenterPoint.Z)
end

function Ability_Task_MoveTo:MoveToDungeonSTP(Context, Character)
    local TargetLocation, TargetRotation = self:GetConfigDungeonSTP(Character)
    -- 如果未匹配到正确的STP点则返回
    if TargetLocation == nil then
        return
    end

    -- 当配置了随机半径则在xy平面上随机选择一个点
    if self.STPRandomRadius ~= 0 then
        TargetLocation = self:GetRandomPointInCircle(TargetLocation, self.STPRandomRadius)
    end

    -- 忽略Yaw轴转动
    if self.IgnoreRotationYaw then
        local Owner = Context:GetOwner()
        if Owner then
            local SelfRotation = Owner:K2_GetActorRotation()
            self:MoveAndTurnTo(Context, Character, TargetLocation, SelfRotation.Yaw)
        end
    else
        self:MoveAndTurnTo(Context, Character, TargetLocation, TargetRotation.Y)
    end
end

function Ability_Task_MoveTo:MoveAndTurnTo(Context, TargetActor, Location, YawAngle)
    if not Context or not TargetActor then
        return
    end

    local Handle = nil
    if self.UseCurve then
        local params = UE4.USPCharacterMovementLibrary.GetSpeedCurveParameter(self.HSpeedCurve, 1.0, nil, 1.0, self.PredictTime)
        local config = UE4.USPCharacterMovementLibrary.GetMovementConfigV2(self.UseVertical, 0, 0, 0, self.IgnoreRotationPitch, self.IgnoreRotationYaw, self.IgnoreRotationRoll, self.HToleranceDistance, self.PredictTime, true)
        Handle = TargetActor:MoveToTargetLocationAndYawByDistanceRateCurve(Location, YawAngle, params, config)
    else
        local selfLocation = TargetActor:K2_GetActorLocation()
        local worldDir = Location - selfLocation
        local distance = UE4.FVector2D(worldDir.X,worldDir.Y):Size()
        worldDir = UE4.UKismetMathLibrary.Vector_Normal2D(worldDir)

        local params = UE4.USPCharacterMovementLibrary.GetDistanceParameter(self.HStartSpeed, 0, self.HStartSpeed, 0, false, distance)
        local config = UE4.USPCharacterMovementLibrary.GetMovementConfigV2(self.UseVertical, 0, 0, 0, self.IgnoreRotationPitch, self.IgnoreRotationYaw, self.IgnoreRotationRoll, self.HToleranceDistance, self.Timeout, true)

        Handle = TargetActor:MoveWorldDirByDistance(worldDir, params, config)
        _SP.LogWarning("SPAbility", "[Ability_Task_MoveTo]", "worldDir: ", worldDir, "distance: ", distance, "CurLocation", selfLocation, "TargetLocation", Location)
    end

    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        return
    end
    ScratchPad.TargetYawAngle = YawAngle
    ScratchPad.Handle = Handle
end

function Ability_Task_MoveTo:MoveTo(Context, Target, Location)
    local Handle = nil
    if self.UseCurve then

        local params = UE4.USPCharacterMovementLibrary.GetSpeedCurveParameter(self.HSpeedCurve, self.MaxHSpeed, nil, 0, self.PredictTime)
        local config = UE4.USPCharacterMovementLibrary.GetMovementConfigV2(self.UseVertical, 0, 0, 0, self.IgnoreRotationPitch, self.IgnoreRotationYaw, self.IgnoreRotationRoll, self.HToleranceDistance, self.Timeout, true)

        Handle = Target:MoveToTargetLocationByCurve(Location, params, config)
    else
        local selfLocation = Target:K2_GetActorLocation()
        local worldDir = Location - selfLocation
        local distance = UE4.FVector2D(worldDir.X,worldDir.Y):Size()
        worldDir = UE4.UKismetMathLibrary.Vector_Normal2D(worldDir)

        local params = UE4.USPCharacterMovementLibrary.GetDistanceParameter(self.HStartSpeed, 0, self.HStartSpeed, 0, false, distance)
        local config = UE4.USPCharacterMovementLibrary.GetMovementConfigV2(self.UseVertical, 0, 0, 0, self.IgnoreRotationPitch, self.IgnoreRotationYaw, self.IgnoreRotationRoll, self.HToleranceDistance, self.Timeout, true)

        Handle = Target:MoveWorldDirByDistance(worldDir, params, config)
        _SP.LogWarning("SPAbility", "[Ability_Task_MoveTo]", "worldDir: ", worldDir, "distance: ", distance, "CurLocation", selfLocation, "TargetLocation", Location)
    end

    local ScratchPad = self:GetScratchPad(Context)
    if not ScratchPad then
        return
    end

    ScratchPad.Handle = Handle
end

function Ability_Task_MoveTo:CheckIsMoveEnd(Context)
    if self.bMoveOverAndSegment then
        local ScratchPad = self:GetScratchPad(Context)
        if not ScratchPad or not ScratchPad.Handle then
            return
        end

        if ScratchPad.Handle:IsCompleted() then
            _SP.LogWarning("SPAbility", "[Ability_Task_MoveTo]", "MoveHandle is Completedly")
            self:DoBranchSegment(Context)
        end
    end
end

function Ability_Task_MoveTo:DoBranchSegment(Context)
    if self.bMoveOverAndSegment then
        if not Context:GetSelfAbilityComponent():BranchSegmentWithName(Context, self.SegmentName) then
            _SP.LogWarning("SPAbility", "[Ability_Task_MoveTo]", "DoBranchSegment Failed")
        end
    end
end

function Ability_Task_MoveTo:IsSingleFrameBP()
    return false
end

function Ability_Task_MoveTo:ResetScratchPadBP(ScratchPad)
    if ScratchPad then
        ScratchPad.Handle = nil
    end
end

function Ability_Task_MoveTo:GetTaskScratchPadClassBP(Context)
    return SPAbilityUtils.LoadScratchPadClass(SPAbility.ScratchPadClass.MoveTo)
end

function Ability_Task_MoveTo:GetTaskRealmBP()
    return UE4.EAbleAbilityTaskRealm.ATR_ClientAndServer
end

return Ability_Task_MoveTo